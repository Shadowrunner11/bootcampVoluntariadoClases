{"mappings":"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","sources":["node_modules/mermaid/src/diagrams/state/stateRenderer-v2.js","node_modules/mermaid/src/diagrams/state/stateDiagram-v2.ts","node_modules/mermaid/src/diagrams/class/svgDraw.js","node_modules/lodash-es/_getPrototype.js","node_modules/lodash-es/isPlainObject.js"],"sourcesContent":["import * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\nimport { select } from 'd3';\nimport { getConfig } from '../../config';\nimport { render } from '../../dagre-wrapper/index.js';\nimport { log } from '../../logger';\nimport { configureSvgSize } from '../../setupGraphViewbox';\nimport common from '../common/common';\nimport utils from '../../utils';\n\nimport {\n  DEFAULT_DIAGRAM_DIRECTION,\n  DEFAULT_NESTED_DOC_DIR,\n  STMT_STATE,\n  STMT_RELATION,\n  DEFAULT_STATE_TYPE,\n  DIVIDER_TYPE,\n} from './stateCommon';\n\n// --------------------------------------\n// Shapes\nconst SHAPE_STATE = 'rect';\nconst SHAPE_STATE_WITH_DESC = 'rectWithTitle';\nconst SHAPE_START = 'start';\nconst SHAPE_END = 'end';\nconst SHAPE_DIVIDER = 'divider';\nconst SHAPE_GROUP = 'roundedWithTitle';\nconst SHAPE_NOTE = 'note';\nconst SHAPE_NOTEGROUP = 'noteGroup';\n\n// --------------------------------------\n// CSS classes\nconst CSS_DIAGRAM = 'statediagram';\nconst CSS_STATE = 'state';\nconst CSS_DIAGRAM_STATE = `${CSS_DIAGRAM}-${CSS_STATE}`;\nconst CSS_EDGE = 'transition';\nconst CSS_NOTE = 'note';\nconst CSS_NOTE_EDGE = 'note-edge';\nconst CSS_EDGE_NOTE_EDGE = `${CSS_EDGE} ${CSS_NOTE_EDGE}`;\nconst CSS_DIAGRAM_NOTE = `${CSS_DIAGRAM}-${CSS_NOTE}`;\nconst CSS_CLUSTER = 'cluster';\nconst CSS_DIAGRAM_CLUSTER = `${CSS_DIAGRAM}-${CSS_CLUSTER}`;\nconst CSS_CLUSTER_ALT = 'cluster-alt';\nconst CSS_DIAGRAM_CLUSTER_ALT = `${CSS_DIAGRAM}-${CSS_CLUSTER_ALT}`;\n\n// --------------------------------------\n// DOM and element IDs\nconst PARENT = 'parent';\nconst NOTE = 'note';\nconst DOMID_STATE = 'state';\nconst DOMID_TYPE_SPACER = '----';\nconst NOTE_ID = `${DOMID_TYPE_SPACER}${NOTE}`;\nconst PARENT_ID = `${DOMID_TYPE_SPACER}${PARENT}`;\n// --------------------------------------\n// Graph edge settings\nconst G_EDGE_STYLE = 'fill:none';\nconst G_EDGE_ARROWHEADSTYLE = 'fill: #333';\nconst G_EDGE_LABELPOS = 'c';\nconst G_EDGE_LABELTYPE = 'text';\nconst G_EDGE_THICKNESS = 'normal';\n\n// --------------------------------------\n// List of nodes created from the parsed diagram statement items\nlet nodeDb = {};\n\nlet graphItemCount = 0; // used to construct ids, etc.\n\n// Configuration\nconst conf = {};\n\n// -----------------------------------------------------------------------\n\nexport const setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\n\n/**\n * Returns the all the classdef styles (a.k.a. classes) from classDef statements in the graph definition.\n *\n * @param {string} text - the diagram text to be parsed\n * @param diagramObj\n * @returns {object} ClassDef styles (a Map with keys = strings, values = )\n */\nexport const getClasses = function (text, diagramObj) {\n  log.trace('Extracting classes');\n  diagramObj.db.clear();\n  try {\n    // Parse the graph definition\n    diagramObj.parser.parse(text);\n    // must run extract() to turn the parsed statements into states, relationships, classes, etc.\n    diagramObj.db.extract(diagramObj.db.getRootDocV2());\n    return diagramObj.db.getClasses();\n  } catch (e) {\n    return e;\n  }\n};\n\n/**\n * Get classes from the db for the info item.\n * If there aren't any or if dbInfoItem isn't defined, return an empty string.\n * Else create 1 string from the list of classes found\n *\n * @param {undefined | null | object} dbInfoItem\n * @returns {string}\n */\nfunction getClassesFromDbInfo(dbInfoItem) {\n  if (dbInfoItem === undefined || dbInfoItem === null) {\n    return '';\n  } else {\n    if (dbInfoItem.classes) {\n      return dbInfoItem.classes.join(' ');\n    } else {\n      return '';\n    }\n  }\n}\n\n/**\n * Create a standard string for the dom ID of an item.\n * If a type is given, insert that before the counter, preceded by the type spacer\n *\n * @param itemId\n * @param counter\n * @param {string | null} type\n * @param typeSpacer\n * @returns {string}\n */\nexport function stateDomId(itemId = '', counter = 0, type = '', typeSpacer = DOMID_TYPE_SPACER) {\n  const typeStr = type !== null && type.length > 0 ? `${typeSpacer}${type}` : '';\n  return `${DOMID_STATE}-${itemId}${typeStr}-${counter}`;\n}\n\n/**\n * Create a graph node based on the statement information\n *\n * @param g - graph\n * @param {object} parent\n * @param {object} parsedItem - parsed statement item\n * @param {object[]} diagramStates - the list of all known  states for the diagram\n * @param {object} diagramDb\n * @param {boolean} altFlag - for clusters, add the \"statediagram-cluster-alt\" CSS class\n */\nconst setupNode = (g, parent, parsedItem, diagramStates, diagramDb, altFlag) => {\n  const itemId = parsedItem.id;\n  const classStr = getClassesFromDbInfo(diagramStates[itemId]);\n\n  if (itemId !== 'root') {\n    let shape = SHAPE_STATE;\n    if (parsedItem.start === true) {\n      shape = SHAPE_START;\n    }\n    if (parsedItem.start === false) {\n      shape = SHAPE_END;\n    }\n    if (parsedItem.type !== DEFAULT_STATE_TYPE) {\n      shape = parsedItem.type;\n    }\n\n    // Add the node to our list (nodeDb)\n    if (!nodeDb[itemId]) {\n      nodeDb[itemId] = {\n        id: itemId,\n        shape,\n        description: common.sanitizeText(itemId, getConfig()),\n        classes: `${classStr} ${CSS_DIAGRAM_STATE}`,\n      };\n    }\n\n    const newNode = nodeDb[itemId];\n\n    // Save data for description and group so that for instance a statement without description overwrites\n    // one with description  @todo TODO What does this mean? If important, add a test for it\n\n    // Build of the array of description strings\n    if (parsedItem.description) {\n      if (Array.isArray(newNode.description)) {\n        // There already is an array of strings,add to it\n        newNode.shape = SHAPE_STATE_WITH_DESC;\n        newNode.description.push(parsedItem.description);\n      } else {\n        if (newNode.description.length > 0) {\n          // if there is a description already transform it to an array\n          newNode.shape = SHAPE_STATE_WITH_DESC;\n          if (newNode.description === itemId) {\n            // If the previous description was this, remove it\n            newNode.description = [parsedItem.description];\n          } else {\n            newNode.description = [newNode.description, parsedItem.description];\n          }\n        } else {\n          newNode.shape = SHAPE_STATE;\n          newNode.description = parsedItem.description;\n        }\n      }\n      newNode.description = common.sanitizeTextOrArray(newNode.description, getConfig());\n    }\n\n    // If there's only 1 description entry, just use a regular state shape\n    if (newNode.description.length === 1 && newNode.shape === SHAPE_STATE_WITH_DESC) {\n      newNode.shape = SHAPE_STATE;\n    }\n\n    // group\n    if (!newNode.type && parsedItem.doc) {\n      log.info('Setting cluster for ', itemId, getDir(parsedItem));\n      newNode.type = 'group';\n      newNode.dir = getDir(parsedItem);\n      newNode.shape = parsedItem.type === DIVIDER_TYPE ? SHAPE_DIVIDER : SHAPE_GROUP;\n      newNode.classes =\n        newNode.classes +\n        ' ' +\n        CSS_DIAGRAM_CLUSTER +\n        ' ' +\n        (altFlag ? CSS_DIAGRAM_CLUSTER_ALT : '');\n    }\n\n    // This is what will be added to the graph\n    const nodeData = {\n      labelStyle: '',\n      shape: newNode.shape,\n      labelText: newNode.description,\n      // typeof newNode.description === 'object'\n      //   ? newNode.description[0]\n      //   : newNode.description,\n      classes: newNode.classes,\n      style: '', //styles.style,\n      id: itemId,\n      dir: newNode.dir,\n      domId: stateDomId(itemId, graphItemCount),\n      type: newNode.type,\n      padding: 15, //getConfig().flowchart.padding\n    };\n    // if (useHtmlLabels) {\n    nodeData.centerLabel = true;\n    // }\n\n    if (parsedItem.note) {\n      // Todo: set random id\n      const noteData = {\n        labelStyle: '',\n        shape: SHAPE_NOTE,\n        labelText: parsedItem.note.text,\n        classes: CSS_DIAGRAM_NOTE,\n        // useHtmlLabels: false,\n        style: '', // styles.style,\n        id: itemId + NOTE_ID + '-' + graphItemCount,\n        domId: stateDomId(itemId, graphItemCount, NOTE),\n        type: newNode.type,\n        padding: 15, //getConfig().flowchart.padding\n      };\n      const groupData = {\n        labelStyle: '',\n        shape: SHAPE_NOTEGROUP,\n        labelText: parsedItem.note.text,\n        classes: newNode.classes,\n        style: '', // styles.style,\n        id: itemId + PARENT_ID,\n        domId: stateDomId(itemId, graphItemCount, PARENT),\n        type: 'group',\n        padding: 0, //getConfig().flowchart.padding\n      };\n      graphItemCount++;\n\n      const parentNodeId = itemId + PARENT_ID;\n      g.setNode(parentNodeId, groupData);\n\n      g.setNode(noteData.id, noteData);\n      g.setNode(itemId, nodeData);\n\n      g.setParent(itemId, parentNodeId);\n      g.setParent(noteData.id, parentNodeId);\n\n      let from = itemId;\n      let to = noteData.id;\n\n      if (parsedItem.note.position === 'left of') {\n        from = noteData.id;\n        to = itemId;\n      }\n      g.setEdge(from, to, {\n        arrowhead: 'none',\n        arrowType: '',\n        style: G_EDGE_STYLE,\n        labelStyle: '',\n        classes: CSS_EDGE_NOTE_EDGE,\n        arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n        labelpos: G_EDGE_LABELPOS,\n        labelType: G_EDGE_LABELTYPE,\n        thickness: G_EDGE_THICKNESS,\n      });\n    } else {\n      g.setNode(itemId, nodeData);\n    }\n  }\n\n  if (parent && parent.id !== 'root') {\n    log.trace('Setting node ', itemId, ' to be child of its parent ', parent.id);\n    g.setParent(itemId, parent.id);\n  }\n  if (parsedItem.doc) {\n    log.trace('Adding nodes children ');\n    setupDoc(g, parsedItem, parsedItem.doc, diagramStates, diagramDb, !altFlag);\n  }\n};\n\n/**\n * Turn parsed statements (item.stmt) into nodes, relationships, etc. for a document.\n * (A document may be nested within others.)\n *\n * @param g\n * @param parentParsedItem - parsed Item that is the parent of this document (doc)\n * @param doc - the document to set up; it is a list of parsed statements\n * @param {object[]} diagramStates - the list of all known states for the diagram\n * @param diagramDb\n * @param {boolean} altFlag\n * @todo This duplicates some of what is done in stateDb.js extract method\n */\nconst setupDoc = (g, parentParsedItem, doc, diagramStates, diagramDb, altFlag) => {\n  // graphItemCount = 0;\n  log.trace('items', doc);\n  doc.forEach((item) => {\n    switch (item.stmt) {\n      case STMT_STATE:\n        setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);\n        break;\n      case DEFAULT_STATE_TYPE:\n        setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);\n        break;\n      case STMT_RELATION:\n        {\n          setupNode(g, parentParsedItem, item.state1, diagramStates, diagramDb, altFlag);\n          setupNode(g, parentParsedItem, item.state2, diagramStates, diagramDb, altFlag);\n          const edgeData = {\n            id: 'edge' + graphItemCount,\n            arrowhead: 'normal',\n            arrowTypeEnd: 'arrow_barb',\n            style: G_EDGE_STYLE,\n            labelStyle: '',\n            label: common.sanitizeText(item.description, getConfig()),\n            arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n            labelpos: G_EDGE_LABELPOS,\n            labelType: G_EDGE_LABELTYPE,\n            thickness: G_EDGE_THICKNESS,\n            classes: CSS_EDGE,\n          };\n          g.setEdge(item.state1.id, item.state2.id, edgeData, graphItemCount);\n          graphItemCount++;\n        }\n        break;\n    }\n  });\n};\n\n/**\n * Get the direction from the statement items.\n * Look through all of the documents (docs) in the parsedItems\n * Because is a _document_ direction, the default direction is not necessarily the same as the overall default _diagram_ direction.\n * @param {object[]} parsedItem - the parsed statement item to look through\n * @param [defaultDir=DEFAULT_NESTED_DOC_DIR] - the direction to use if none is found\n * @returns {string}\n */\nconst getDir = (parsedItem, defaultDir = DEFAULT_NESTED_DOC_DIR) => {\n  let dir = defaultDir;\n  if (parsedItem.doc) {\n    for (let i = 0; i < parsedItem.doc.length; i++) {\n      const parsedItemDoc = parsedItem.doc[i];\n      if (parsedItemDoc.stmt === 'dir') {\n        dir = parsedItemDoc.value;\n      }\n    }\n  }\n  return dir;\n};\n\n/**\n * Draws a state diagram in the tag with id: id based on the graph definition in text.\n *\n * @param {any} text\n * @param {any} id\n * @param _version\n * @param diag\n */\nexport const draw = function (text, id, _version, diag) {\n  log.info('Drawing state diagram (v2)', id);\n  // diag.sb.clear();\n  nodeDb = {};\n  // Fetch the default direction, use TD if none was found\n  let dir = diag.db.getDirection();\n  if (dir === undefined) {\n    dir = DEFAULT_DIAGRAM_DIRECTION;\n  }\n\n  const { securityLevel, state: conf } = getConfig();\n  const nodeSpacing = conf.nodeSpacing || 50;\n  const rankSpacing = conf.rankSpacing || 50;\n\n  log.info(diag.db.getRootDocV2());\n\n  // This parses the diagram text and sets the classes, relations, styles, classDefs, etc.\n  diag.db.extract(diag.db.getRootDocV2());\n  log.info(diag.db.getRootDocV2());\n\n  const diagramStates = diag.db.getStates();\n\n  // Create the input mermaid.graph\n  const g = new graphlib.Graph({\n    multigraph: true,\n    compound: true,\n  })\n    .setGraph({\n      rankdir: getDir(diag.db.getRootDocV2()),\n      nodesep: nodeSpacing,\n      ranksep: rankSpacing,\n      marginx: 8,\n      marginy: 8,\n    })\n    .setDefaultEdgeLabel(function () {\n      return {};\n    });\n\n  setupNode(g, undefined, diag.db.getRootDocV2(), diagramStates, diag.db, true);\n\n  // Set up an SVG group so that we can translate the final graph.\n  let sandboxElement;\n  if (securityLevel === 'sandbox') {\n    sandboxElement = select('#i' + id);\n  }\n  const root =\n    securityLevel === 'sandbox'\n      ? select(sandboxElement.nodes()[0].contentDocument.body)\n      : select('body');\n  const svg = root.select(`[id=\"${id}\"]`);\n\n  // Run the renderer. This is what draws the final graph.\n\n  const element = root.select('#' + id + ' g');\n  render(element, g, ['barb'], CSS_DIAGRAM, id);\n\n  const padding = 8;\n\n  utils.insertTitle(svg, 'statediagramTitleText', conf.titleTopMargin, diag.db.getDiagramTitle());\n\n  const bounds = svg.node().getBBox();\n  const width = bounds.width + padding * 2;\n  const height = bounds.height + padding * 2;\n\n  // Zoom in a bit\n  svg.attr('class', CSS_DIAGRAM);\n\n  const svgBounds = svg.node().getBBox();\n\n  configureSvgSize(svg, height, width, conf.useMaxWidth);\n\n  // Ensure the viewBox includes the whole svgBounds area with extra space for padding\n  const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${width} ${height}`;\n  log.debug(`viewBox ${vBox}`);\n  svg.attr('viewBox', vBox);\n\n  // Add label rects for non html labels\n  // if (!evaluate(conf.htmlLabels) || true) {\n  const labels = document.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n  for (const label of labels) {\n    // Get dimensions of label\n    const dim = label.getBBox();\n\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', SHAPE_STATE);\n    rect.setAttribute('rx', 0);\n    rect.setAttribute('ry', 0);\n    rect.setAttribute('width', dim.width);\n    rect.setAttribute('height', dim.height);\n\n    label.insertBefore(rect, label.firstChild);\n    // }\n  }\n};\n\nexport default {\n  setConf,\n  getClasses,\n  draw,\n};\n","import { DiagramDefinition } from '../../diagram-api/types';\n// @ts-ignore: TODO Fix ts errors\nimport parser from './parser/stateDiagram';\nimport db from './stateDb';\nimport styles from './styles';\nimport renderer from './stateRenderer-v2';\n\nexport const diagram: DiagramDefinition = {\n  parser,\n  db,\n  renderer,\n  styles,\n  init: (cnf) => {\n    if (!cnf.state) {\n      cnf.state = {};\n    }\n    cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    db.clear();\n  },\n};\n","import { line, curveBasis } from 'd3';\nimport utils from '../../utils';\nimport { log } from '../../logger';\nimport { parseGenericTypes } from '../common/common';\n\nlet edgeCount = 0;\nexport const drawEdge = function (elem, path, relation, conf, diagObj) {\n  const getRelationType = function (type) {\n    switch (type) {\n      case diagObj.db.relationType.AGGREGATION:\n        return 'aggregation';\n      case diagObj.db.relationType.EXTENSION:\n        return 'extension';\n      case diagObj.db.relationType.COMPOSITION:\n        return 'composition';\n      case diagObj.db.relationType.DEPENDENCY:\n        return 'dependency';\n      case diagObj.db.relationType.LOLLIPOP:\n        return 'lollipop';\n    }\n  };\n\n  path.points = path.points.filter((p) => !Number.isNaN(p.y));\n\n  // The data for our line\n  const lineData = path.points;\n\n  // This is the accessor function we talked about above\n  const lineFunction = line()\n    .x(function (d) {\n      return d.x;\n    })\n    .y(function (d) {\n      return d.y;\n    })\n    .curve(curveBasis);\n\n  const svgPath = elem\n    .append('path')\n    .attr('d', lineFunction(lineData))\n    .attr('id', 'edge' + edgeCount)\n    .attr('class', 'relation');\n  let url = '';\n  if (conf.arrowMarkerAbsolute) {\n    url =\n      window.location.protocol +\n      '//' +\n      window.location.host +\n      window.location.pathname +\n      window.location.search;\n    url = url.replace(/\\(/g, '\\\\(');\n    url = url.replace(/\\)/g, '\\\\)');\n  }\n\n  if (relation.relation.lineType == 1) {\n    svgPath.attr('class', 'relation dashed-line');\n  }\n  if (relation.relation.lineType == 10) {\n    svgPath.attr('class', 'relation dotted-line');\n  }\n  if (relation.relation.type1 !== 'none') {\n    svgPath.attr(\n      'marker-start',\n      'url(' + url + '#' + getRelationType(relation.relation.type1) + 'Start' + ')'\n    );\n  }\n  if (relation.relation.type2 !== 'none') {\n    svgPath.attr(\n      'marker-end',\n      'url(' + url + '#' + getRelationType(relation.relation.type2) + 'End' + ')'\n    );\n  }\n\n  let x, y;\n  const l = path.points.length;\n  // Calculate Label position\n  let labelPosition = utils.calcLabelPosition(path.points);\n  x = labelPosition.x;\n  y = labelPosition.y;\n\n  let p1_card_x, p1_card_y;\n  let p2_card_x, p2_card_y;\n\n  if (l % 2 !== 0 && l > 1) {\n    let cardinality_1_point = utils.calcCardinalityPosition(\n      relation.relation.type1 !== 'none',\n      path.points,\n      path.points[0]\n    );\n    let cardinality_2_point = utils.calcCardinalityPosition(\n      relation.relation.type2 !== 'none',\n      path.points,\n      path.points[l - 1]\n    );\n\n    log.debug('cardinality_1_point ' + JSON.stringify(cardinality_1_point));\n    log.debug('cardinality_2_point ' + JSON.stringify(cardinality_2_point));\n\n    p1_card_x = cardinality_1_point.x;\n    p1_card_y = cardinality_1_point.y;\n    p2_card_x = cardinality_2_point.x;\n    p2_card_y = cardinality_2_point.y;\n  }\n\n  if (relation.title !== undefined) {\n    const g = elem.append('g').attr('class', 'classLabel');\n    const label = g\n      .append('text')\n      .attr('class', 'label')\n      .attr('x', x)\n      .attr('y', y)\n      .attr('fill', 'red')\n      .attr('text-anchor', 'middle')\n      .text(relation.title);\n\n    window.label = label;\n    const bounds = label.node().getBBox();\n\n    g.insert('rect', ':first-child')\n      .attr('class', 'box')\n      .attr('x', bounds.x - conf.padding / 2)\n      .attr('y', bounds.y - conf.padding / 2)\n      .attr('width', bounds.width + conf.padding)\n      .attr('height', bounds.height + conf.padding);\n  }\n\n  log.info('Rendering relation ' + JSON.stringify(relation));\n  if (relation.relationTitle1 !== undefined && relation.relationTitle1 !== 'none') {\n    const g = elem.append('g').attr('class', 'cardinality');\n    g.append('text')\n      .attr('class', 'type1')\n      .attr('x', p1_card_x)\n      .attr('y', p1_card_y)\n      .attr('fill', 'black')\n      .attr('font-size', '6')\n      .text(relation.relationTitle1);\n  }\n  if (relation.relationTitle2 !== undefined && relation.relationTitle2 !== 'none') {\n    const g = elem.append('g').attr('class', 'cardinality');\n    g.append('text')\n      .attr('class', 'type2')\n      .attr('x', p2_card_x)\n      .attr('y', p2_card_y)\n      .attr('fill', 'black')\n      .attr('font-size', '6')\n      .text(relation.relationTitle2);\n  }\n\n  edgeCount++;\n};\n\n/**\n * Renders a class diagram\n *\n * @param {SVGSVGElement} elem The element to draw it into\n * @param classDef\n * @param conf\n * @param diagObj\n * @todo Add more information in the JSDOC here\n */\nexport const drawClass = function (elem, classDef, conf, diagObj) {\n  log.debug('Rendering class ', classDef, conf);\n\n  const id = classDef.id;\n  const classInfo = {\n    id: id,\n    label: classDef.id,\n    width: 0,\n    height: 0,\n  };\n\n  // add class group\n  const g = elem.append('g').attr('id', diagObj.db.lookUpDomId(id)).attr('class', 'classGroup');\n\n  // add title\n  let title;\n  if (classDef.link) {\n    title = g\n      .append('svg:a')\n      .attr('xlink:href', classDef.link)\n      .attr('target', classDef.linkTarget)\n      .append('text')\n      .attr('y', conf.textHeight + conf.padding)\n      .attr('x', 0);\n  } else {\n    title = g\n      .append('text')\n      .attr('y', conf.textHeight + conf.padding)\n      .attr('x', 0);\n  }\n\n  // add annotations\n  let isFirst = true;\n  classDef.annotations.forEach(function (member) {\n    const titleText2 = title.append('tspan').text('«' + member + '»');\n    if (!isFirst) {\n      titleText2.attr('dy', conf.textHeight);\n    }\n    isFirst = false;\n  });\n\n  let classTitleString = classDef.id;\n\n  if (classDef.type !== undefined && classDef.type !== '') {\n    classTitleString += '<' + classDef.type + '>';\n  }\n\n  const classTitle = title.append('tspan').text(classTitleString).attr('class', 'title');\n\n  // If class has annotations the title needs to have an offset of the text height\n  if (!isFirst) {\n    classTitle.attr('dy', conf.textHeight);\n  }\n\n  const titleHeight = title.node().getBBox().height;\n\n  const membersLine = g\n    .append('line') // text label for the x axis\n    .attr('x1', 0)\n    .attr('y1', conf.padding + titleHeight + conf.dividerMargin / 2)\n    .attr('y2', conf.padding + titleHeight + conf.dividerMargin / 2);\n\n  const members = g\n    .append('text') // text label for the x axis\n    .attr('x', conf.padding)\n    .attr('y', titleHeight + conf.dividerMargin + conf.textHeight)\n    .attr('fill', 'white')\n    .attr('class', 'classText');\n\n  isFirst = true;\n  classDef.members.forEach(function (member) {\n    addTspan(members, member, isFirst, conf);\n    isFirst = false;\n  });\n\n  const membersBox = members.node().getBBox();\n\n  const methodsLine = g\n    .append('line') // text label for the x axis\n    .attr('x1', 0)\n    .attr('y1', conf.padding + titleHeight + conf.dividerMargin + membersBox.height)\n    .attr('y2', conf.padding + titleHeight + conf.dividerMargin + membersBox.height);\n\n  const methods = g\n    .append('text') // text label for the x axis\n    .attr('x', conf.padding)\n    .attr('y', titleHeight + 2 * conf.dividerMargin + membersBox.height + conf.textHeight)\n    .attr('fill', 'white')\n    .attr('class', 'classText');\n\n  isFirst = true;\n\n  classDef.methods.forEach(function (method) {\n    addTspan(methods, method, isFirst, conf);\n    isFirst = false;\n  });\n\n  const classBox = g.node().getBBox();\n  var cssClassStr = ' ';\n\n  if (classDef.cssClasses.length > 0) {\n    cssClassStr = cssClassStr + classDef.cssClasses.join(' ');\n  }\n\n  const rect = g\n    .insert('rect', ':first-child')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', classBox.width + 2 * conf.padding)\n    .attr('height', classBox.height + conf.padding + 0.5 * conf.dividerMargin)\n    .attr('class', cssClassStr);\n\n  const rectWidth = rect.node().getBBox().width;\n\n  // Center title\n  // We subtract the width of each text element from the class box width and divide it by 2\n  title.node().childNodes.forEach(function (x) {\n    x.setAttribute('x', (rectWidth - x.getBBox().width) / 2);\n  });\n\n  if (classDef.tooltip) {\n    title.insert('title').text(classDef.tooltip);\n  }\n\n  membersLine.attr('x2', rectWidth);\n  methodsLine.attr('x2', rectWidth);\n\n  classInfo.width = rectWidth;\n  classInfo.height = classBox.height + conf.padding + 0.5 * conf.dividerMargin;\n\n  return classInfo;\n};\n\n/**\n * Renders a note diagram\n *\n * @param {SVGSVGElement} elem The element to draw it into\n * @param {{id: string; text: string; class: string;}} note\n * @param conf\n * @param diagObj\n * @todo Add more information in the JSDOC here\n */\nexport const drawNote = function (elem, note, conf, diagObj) {\n  log.debug('Rendering note ', note, conf);\n\n  const id = note.id;\n  const noteInfo = {\n    id: id,\n    text: note.text,\n    width: 0,\n    height: 0,\n  };\n\n  // add class group\n  const g = elem.append('g').attr('id', id).attr('class', 'classGroup');\n\n  // add text\n  let text = g\n    .append('text')\n    .attr('y', conf.textHeight + conf.padding)\n    .attr('x', 0);\n\n  const lines = JSON.parse(`\"${note.text}\"`).split('\\n');\n\n  lines.forEach(function (line) {\n    log.debug(`Adding line: ${line}`);\n    text.append('tspan').text(line).attr('class', 'title').attr('dy', conf.textHeight);\n  });\n\n  const noteBox = g.node().getBBox();\n\n  const rect = g\n    .insert('rect', ':first-child')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', noteBox.width + 2 * conf.padding)\n    .attr(\n      'height',\n      noteBox.height + lines.length * conf.textHeight + conf.padding + 0.5 * conf.dividerMargin\n    );\n\n  const rectWidth = rect.node().getBBox().width;\n\n  // Center title\n  // We subtract the width of each text element from the class box width and divide it by 2\n  text.node().childNodes.forEach(function (x) {\n    x.setAttribute('x', (rectWidth - x.getBBox().width) / 2);\n  });\n\n  noteInfo.width = rectWidth;\n  noteInfo.height =\n    noteBox.height + lines.length * conf.textHeight + conf.padding + 0.5 * conf.dividerMargin;\n\n  return noteInfo;\n};\n\nexport const parseMember = function (text) {\n  const fieldRegEx = /^([#+~-])?(\\w+)(~\\w+~|\\[])?\\s+(\\w+) *([$*])?$/;\n  const methodRegEx = /^([#+|~-])?(\\w+) *\\( *(.*)\\) *([$*])? *(\\w*[[\\]|~]*\\s*\\w*~?)$/;\n\n  let fieldMatch = text.match(fieldRegEx);\n  let methodMatch = text.match(methodRegEx);\n\n  if (fieldMatch && !methodMatch) {\n    return buildFieldDisplay(fieldMatch);\n  } else if (methodMatch) {\n    return buildMethodDisplay(methodMatch);\n  } else {\n    return buildLegacyDisplay(text);\n  }\n};\n\nconst buildFieldDisplay = function (parsedText) {\n  let cssStyle = '';\n  let displayText = '';\n\n  try {\n    let visibility = parsedText[1] ? parsedText[1].trim() : '';\n    let fieldType = parsedText[2] ? parsedText[2].trim() : '';\n    let genericType = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : '';\n    let fieldName = parsedText[4] ? parsedText[4].trim() : '';\n    let classifier = parsedText[5] ? parsedText[5].trim() : '';\n\n    displayText = visibility + fieldType + genericType + ' ' + fieldName;\n    cssStyle = parseClassifier(classifier);\n  } catch (err) {\n    displayText = parsedText;\n  }\n\n  return {\n    displayText: displayText,\n    cssStyle: cssStyle,\n  };\n};\n\nconst buildMethodDisplay = function (parsedText) {\n  let cssStyle = '';\n  let displayText = '';\n\n  try {\n    let visibility = parsedText[1] ? parsedText[1].trim() : '';\n    let methodName = parsedText[2] ? parsedText[2].trim() : '';\n    let parameters = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : '';\n    let classifier = parsedText[4] ? parsedText[4].trim() : '';\n    let returnType = parsedText[5] ? ' : ' + parseGenericTypes(parsedText[5]).trim() : '';\n\n    displayText = visibility + methodName + '(' + parameters + ')' + returnType;\n    cssStyle = parseClassifier(classifier);\n  } catch (err) {\n    displayText = parsedText;\n  }\n\n  return {\n    displayText: displayText,\n    cssStyle: cssStyle,\n  };\n};\n\nconst buildLegacyDisplay = function (text) {\n  // if for some reason we don't have any match, use old format to parse text\n  let displayText = '';\n  let cssStyle = '';\n  let returnType = '';\n  let methodStart = text.indexOf('(');\n  let methodEnd = text.indexOf(')');\n\n  if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text.length) {\n    let visibility = '';\n    let methodName = '';\n\n    let firstChar = text.substring(0, 1);\n    if (firstChar.match(/\\w/)) {\n      methodName = text.substring(0, methodStart).trim();\n    } else {\n      if (firstChar.match(/[#+~-]/)) {\n        visibility = firstChar;\n      }\n\n      methodName = text.substring(1, methodStart).trim();\n    }\n\n    const parameters = text.substring(methodStart + 1, methodEnd);\n    const classifier = text.substring(methodEnd + 1, 1);\n    cssStyle = parseClassifier(text.substring(methodEnd + 1, methodEnd + 2));\n\n    displayText = visibility + methodName + '(' + parseGenericTypes(parameters.trim()) + ')';\n\n    if (methodEnd < text.length) {\n      returnType = text.substring(methodEnd + 2).trim();\n      if (returnType !== '') {\n        returnType = ' : ' + parseGenericTypes(returnType);\n        displayText += returnType;\n      }\n    }\n  } else {\n    // finally - if all else fails, just send the text back as written (other than parsing for generic types)\n    displayText = parseGenericTypes(text);\n  }\n\n  return {\n    displayText,\n    cssStyle,\n  };\n};\n/**\n * Adds a <tspan> for a member in a diagram\n *\n * @param {SVGElement} textEl The element to append to\n * @param {string} txt The member\n * @param {boolean} isFirst\n * @param {{ padding: string; textHeight: string }} conf The configuration for the member\n */\nconst addTspan = function (textEl, txt, isFirst, conf) {\n  let member = parseMember(txt);\n\n  const tSpan = textEl.append('tspan').attr('x', conf.padding).text(member.displayText);\n\n  if (member.cssStyle !== '') {\n    tSpan.attr('style', member.cssStyle);\n  }\n\n  if (!isFirst) {\n    tSpan.attr('dy', conf.textHeight);\n  }\n};\n\n/**\n * Gives the styles for a classifier\n *\n * @param {'+' | '-' | '#' | '~' | '*' | '$'} classifier The classifier string\n * @returns {string} Styling for the classifier\n */\nconst parseClassifier = function (classifier) {\n  switch (classifier) {\n    case '*':\n      return 'font-style:italic;';\n    case '$':\n      return 'text-decoration:underline;';\n    default:\n      return '';\n  }\n};\n\nexport default {\n  drawClass,\n  drawEdge,\n  drawNote,\n  parseMember,\n};\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n"],"names":["$5ee7b512944b190a$var$SHAPE_STATE","$5ee7b512944b190a$var$SHAPE_STATE_WITH_DESC","$5ee7b512944b190a$var$CSS_DIAGRAM","$5ee7b512944b190a$var$CSS_DIAGRAM_STATE","$5ee7b512944b190a$var$CSS_EDGE","$5ee7b512944b190a$var$CSS_EDGE_NOTE_EDGE","$5ee7b512944b190a$var$CSS_DIAGRAM_NOTE","$5ee7b512944b190a$var$CSS_DIAGRAM_CLUSTER","$5ee7b512944b190a$var$CSS_DIAGRAM_CLUSTER_ALT","$5ee7b512944b190a$var$PARENT","$5ee7b512944b190a$var$NOTE","$5ee7b512944b190a$var$DOMID_TYPE_SPACER","$5ee7b512944b190a$var$NOTE_ID","$5ee7b512944b190a$var$PARENT_ID","$5ee7b512944b190a$var$G_EDGE_STYLE","$5ee7b512944b190a$var$G_EDGE_ARROWHEADSTYLE","$5ee7b512944b190a$var$G_EDGE_LABELTYPE","$5ee7b512944b190a$var$G_EDGE_THICKNESS","$5ee7b512944b190a$var$nodeDb","$5ee7b512944b190a$var$graphItemCount","$5ee7b512944b190a$var$stateDomId","itemId","counter","type","typeSpacer","length","$5ee7b512944b190a$var$setupNode","g","parent","parsedItem","diagramStates","diagramDb","altFlag","id","classStr","dbInfoItem","classes","join","shape","start","$g56H2","a","description","$jmbVX","e","sanitizeText","newNode","Array","isArray","push","sanitizeTextOrArray","doc","l","info","$5ee7b512944b190a$var$getDir","dir","b","nodeData","labelStyle","labelText","style","domId","padding","note","noteData","text","groupData","parentNodeId","setNode","setParent","from","to","position","setEdge","arrowhead","arrowType","arrowheadStyle","labelpos","labelType","thickness","trace","$5ee7b512944b190a$var$setupDoc","parentParsedItem","forEach","item","stmt","c","S","state1","state2","edgeData","arrowTypeEnd","label","defaultDir","i","parsedItemDoc","value","$5ee7b512944b190a$var$renderer","cnf","keys","Object","key","diagramObj","db","clear","parser","parse","extract","getRootDocV2","getClasses","_version","diag","getDirection","D","securityLevel","state","conf","nodeSpacing","rankSpacing","getStates","$4LkSm","Graph","multigraph","compound","setGraph","rankdir","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","sandboxElement","$2YFJl","select","root","nodes","contentDocument","body","svg","element","$evFAv","r","$3IUvT","u","insertTitle","titleTopMargin","getDiagramTitle","bounds","node","getBBox","width","height","attr","svgBounds","k","useMaxWidth","vBox","x","y","debug","labels","document","querySelectorAll","dim","rect","createElementNS","setAttribute","insertBefore","firstChild","$5ee7b512944b190a$export$6118d022d940d562","p","d","s","init","arrowMarkerAbsolute","$adefb12e855c4667$var$edgeCount","$adefb12e855c4667$export$ffb5f4729a158638","fieldMatch","match","methodMatch","$adefb12e855c4667$var$buildFieldDisplay","$adefb12e855c4667$var$buildMethodDisplay","$adefb12e855c4667$var$buildLegacyDisplay","parsedText","cssStyle","displayText","visibility","trim","fieldType","genericType","z","fieldName","classifier","$adefb12e855c4667$var$parseClassifier","err","methodName","parameters","returnType","methodStart","indexOf","methodEnd","firstChar","substring","$adefb12e855c4667$var$addTspan","textEl","txt","isFirst","member","tSpan","append","textHeight","$adefb12e855c4667$export$2408f22a0fab9ae5","elem","classDef","diagObj","classInfo","lookUpDomId","title","link","linkTarget","annotations","titleText2","classTitleString","classTitle","titleHeight","membersLine","dividerMargin","members","membersBox","methodsLine","methods","method","classBox","cssClassStr","cssClasses","rectWidth","insert","childNodes","tooltip","path","relation","getRelationType","relationType","AGGREGATION","EXTENSION","COMPOSITION","DEPENDENCY","LOLLIPOP","points","filter","Number","isNaN","lineData","lineFunction","line","curve","curveBasis","svgPath","url","window","location","protocol","host","pathname","search","replace","lineType","type1","type2","p1_card_x","p1_card_y","p2_card_x","p2_card_y","labelPosition","calcLabelPosition","cardinality_1_point","calcCardinalityPosition","cardinality_2_point","JSON","stringify","relationTitle1","relationTitle2","noteInfo","lines","split","noteBox","$86d5c19d81d423c4$export$2e2bcd8739ae039","parcelRequire","default","getPrototypeOf","$hArsG","$281ac82f5f5844b1$var$funcProto","Function","prototype","$281ac82f5f5844b1$var$objectProto","$281ac82f5f5844b1$var$funcToString","toString","$281ac82f5f5844b1$var$hasOwnProperty","hasOwnProperty","$281ac82f5f5844b1$var$objectCtorString","call","$281ac82f5f5844b1$export$2e2bcd8739ae039","$f2iog","proto","$bzIQZ","Ctor","constructor"],"version":3,"file":"stateDiagram-v2-9765461d.9c8d5661.js.map"}