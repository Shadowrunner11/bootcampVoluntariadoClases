{"mappings":"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","sources":["node_modules/mermaid/src/dagre-wrapper/mermaid-graphlib.js","node_modules/mermaid/src/dagre-wrapper/clusters.js","node_modules/mermaid/src/dagre-wrapper/index.js","node_modules/dagre-d3-es/src/graphlib/json.js","node_modules/lodash-es/clone.js"],"sourcesContent":["/** Decorates with functions required by mermaids dagre-wrapper. */\nimport { log } from '../logger';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\n\nexport let clusterDb = {};\nlet descendants = {};\nlet parents = {};\n\nexport const clear = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\n\nconst isDescendant = (id, ancenstorId) => {\n  // if (id === ancenstorId) return true;\n\n  log.trace('In isDecendant', ancenstorId, ' ', id, ' = ', descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst edgeInCluster = (edge, clusterId) => {\n  log.info('Decendants of ', clusterId, ' is ', descendants[clusterId]);\n  log.info('Edge is ', edge);\n  // Edges to/from the cluster is not in the cluster, they are in the parent\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n\n  if (!descendants[clusterId]) {\n    log.debug('Tilt, ', clusterId, ',not in decendants');\n    return false;\n  }\n  return (\n    descendants[clusterId].includes(edge.v) ||\n    isDescendant(edge.v, clusterId) ||\n    isDescendant(edge.w, clusterId) ||\n    descendants[clusterId].includes(edge.w)\n  );\n};\n\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    'Copying children of ',\n    clusterId,\n    'root',\n    rootId,\n    'data',\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n\n  // Include cluster node if it is not the root\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n\n  log.warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);\n\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn('Setting parent', node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug('Setting parent', node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);\n        log.debug(\n          'Not Setting parent for node=',\n          node,\n          'cluster!==rootId',\n          clusterId !== rootId,\n          'node!==clusterId',\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug('Copying Edges', edges);\n      edges.forEach((edge) => {\n        log.info('Edge', edge);\n        const data = graph.edge(edge.v, edge.w, edge.name);\n        log.info('Edge data', data, rootId);\n        try {\n          // Do not copy edges in and out of the root cluster, they belong to the parent graph\n          if (edgeInCluster(edge, rootId)) {\n            log.info('Copying as ', edge.v, edge.w, data, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data, edge.name);\n            log.info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              'Skipping copy of edge ',\n              edge.v,\n              '-->',\n              edge.w,\n              ' rootId: ',\n              rootId,\n              ' clusterId:',\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug('Removing node', node);\n    graph.removeNode(node);\n  });\n};\nexport const extractDescendants = (id, graph) => {\n  // log.debug('Extracting ', id);\n  const children = graph.children(id);\n  let res = [...children];\n\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n\n  return res;\n};\n\n/**\n * Validates the graph, checking that all parent child relation points to existing nodes and that\n * edges between nodes also ia correct. When not correct the function logs the discrepancies.\n *\n * @param graph\n */\nexport const validate = (graph) => {\n  const edges = graph.edges();\n  log.trace('Edges: ', edges);\n  for (const edge of edges) {\n    if (graph.children(edge.v).length > 0) {\n      log.trace('The node ', edge.v, ' is part of and edge even though it has children');\n      return false;\n    }\n    if (graph.children(edge.w).length > 0) {\n      log.trace('The node ', edge.w, ' is part of and edge even though it has children');\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Finds a child that is not a cluster. When faking an edge between a node and a cluster.\n *\n * @param id\n * @param {any} graph\n */\nexport const findNonClusterChild = (id, graph) => {\n  // const node = graph.node(id);\n  log.trace('Searching', id);\n  // const children = graph.children(id).reverse();\n  const children = graph.children(id); //.reverse();\n  log.trace('Searching children of id ', id, children);\n  if (children.length < 1) {\n    log.trace('This is a valid node', id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace('Found replacement for', id, ' => ', _id);\n      return _id;\n    }\n  }\n};\n\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  // If the cluster has no external connections\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n\n  // Return the replacement node\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\n\nexport const adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug('Opting out, no graph ');\n    return;\n  } else {\n    log.debug('Opting in, graph ');\n  }\n  // Go through the nodes and for each cluster found, save a replacement node, this can be used when\n  // faking a link to a cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        'Cluster identified',\n        id,\n        ' Replacement id in edges: ',\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n\n  // Check incoming and outgoing edges for each cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug('Cluster identified', id, descendants);\n      edges.forEach((edge) => {\n        // log.debug('Edge, decendants: ', edge, decendants[id]);\n\n        // Check if any edge leaves the cluster (not the actual cluster, that's a link from the box)\n        if (edge.v !== id && edge.w !== id) {\n          // Any edge where either the one of the nodes is descending to the cluster but not the other\n          // if (decendants[id].indexOf(edge.v) < 0 && decendants[id].indexOf(edge.w) < 0) {\n\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n\n          // d1 xor d2 - if either d1 is true and d2 is false or the other way around\n          if (d1 ^ d2) {\n            log.warn('Edge: ', edge, ' leaves cluster ', id);\n            log.warn('Decendants of XXX ', id, ': ', descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug('Not a cluster ', id, descendants);\n    }\n  });\n\n  // For clusters with incoming and/or outgoing edges translate those edges to a real node\n  // in the cluster in order to fake the edge\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));\n\n    let v = e.v;\n    let w = e.w;\n    // Check if link is either from or to a cluster\n    log.warn(\n      'Fix XXX',\n      clusterDb,\n      'ids:',\n      e.v,\n      e.w,\n      'Translating: ',\n      clusterDb[e.v],\n      ' --- ',\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn('Fixing and trixing link to self - removing XXX', e.v, e.w, e.name);\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + '---' + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: '',\n        labelText: edge.label,\n        padding: 0,\n        shape: 'labelRect',\n        style: '',\n      });\n      const edge1 = JSON.parse(JSON.stringify(edge));\n      const edge2 = JSON.parse(JSON.stringify(edge));\n      edge1.label = '';\n      edge1.arrowTypeEnd = 'none';\n      edge2.label = '';\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n\n      graph.setEdge(v, specialId, edge1, e.name + '-cyclic-special');\n      graph.setEdge(specialId, w, edge2, e.name + '-cyclic-special');\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn('Fix Replacing with XXX', v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn('Adjusted Graph', graphlibJson.write(graph));\n  extractor(graph, 0);\n\n  log.trace(clusterDb);\n\n  // Remove references to extracted cluster\n  // graph.edges().forEach(edge => {\n  //   if (isDecendant(edge.v, clusterId) || isDecendant(edge.w, clusterId)) {\n  //     graph.removeEdge(edge);\n  //   }\n  // });\n};\n\nexport const extractor = (graph, depth) => {\n  log.warn('extractor - ', depth, graphlibJson.write(graph), graph.children('D'));\n  if (depth > 10) {\n    log.error('Bailing out');\n    return;\n  }\n  // For clusters without incoming and/or outgoing edges, create a new cluster-node\n  // containing the nodes and edges in the custer in a new graph\n  // for (let i = 0;)\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n\n  if (!hasChildren) {\n    log.debug('Done, no node has children', graph.nodes());\n    return;\n  }\n  // const clusters = Object.keys(clusterDb);\n  // clusters.forEach(clusterId => {\n  log.debug('Nodes = ', nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      'Extracting node',\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children('D'),\n      ' Depth ',\n      depth\n    );\n    // Note that the node might have been removed after the Object.keys call so better check\n    // that it still is in the game\n    if (!clusterDb[node]) {\n      // Skip if the node is not a cluster\n      log.debug('Not a cluster', node, depth);\n      // break;\n    } else if (\n      !clusterDb[node].externalConnections &&\n      // !graph.parent(node) &&\n      graph.children(node) &&\n      graph.children(node).length > 0\n    ) {\n      log.warn(\n        'Cluster without external connections, without a parent and with children',\n        node,\n        depth\n      );\n\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn('Fixing dir', clusterDb[node].clusterData.dir, dir);\n      }\n\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true,\n      })\n        .setGraph({\n          rankdir: dir, // Todo: set proper spacing\n          nodesep: 50,\n          ranksep: 50,\n          marginx: 8,\n          marginy: 8,\n        })\n        .setDefaultEdgeLabel(function () {\n          return {};\n        });\n\n      log.warn('Old graph before copy', graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph,\n      });\n      log.warn('New graph after copy node: (', node, ')', graphlibJson.write(clusterGraph));\n      log.debug('Old graph after copy', graphlibJson.write(graph));\n    } else {\n      log.warn(\n        'Cluster ** ',\n        node,\n        ' **not meeting the criteria !externalConnections:',\n        !clusterDb[node].externalConnections,\n        ' no parent: ',\n        !graph.parent(node),\n        ' children ',\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children('D'),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n\n  nodes = graph.nodes();\n  log.warn('New list of nodes', nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(' Now next level', node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\n\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n\n  return result;\n};\n\nexport const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\n","import intersectRect from './intersect/intersect-rect';\nimport { log } from '../logger';\nimport createLabel from './createLabel';\nimport { createText } from '../rendering-util/createText';\nimport { select } from 'd3';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\n\nconst rect = (parent, node) => {\n  log.info('Creating subgraph rect for ', node.id, node);\n\n  // Add outer g element\n  const shapeSvg = parent\n    .insert('g')\n    .attr('class', 'cluster' + (node.class ? ' ' + node.class : ''))\n    .attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n\n  // const text = label\n  //   .node()\n  //   .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n  const text =\n    node.labelType === 'markdown'\n      ? createText(label, node.labelText, { style: node.labelStyle, useHtmlLabels })\n      : label.node().appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  log.trace('Data ', node, JSON.stringify(node));\n  // center the rect around its coordinate\n  rect\n    .attr('style', node.style)\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - width / 2)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width)\n    .attr('height', node.height + padding);\n\n  if (useHtmlLabels) {\n    label.attr(\n      'transform',\n      // This puts the labal on top of the box instead of inside it\n      'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2) + ')'\n    );\n  } else {\n    label.attr(\n      'transform',\n      // This puts the labal on top of the box instead of inside it\n      'translate(' + node.x + ', ' + (node.y - node.height / 2) + ')'\n    );\n  }\n  // Center the label\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\n/**\n * Non visible cluster where the note is group with its\n *\n * @param {any} parent\n * @param {any} node\n * @returns {any} ShapeSvg\n */\nconst noteGroup = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding)\n    .attr('fill', 'none');\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n  const innerRect = shapeSvg.append('rect');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'outer')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding);\n  innerRect\n    .attr('class', 'inner')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding - bbox.height - 3);\n\n  // Center the label\n  label.attr(\n    'transform',\n    'translate(' +\n      (node.x - bbox.width / 2) +\n      ', ' +\n      (node.y -\n        node.height / 2 -\n        node.padding / 3 +\n        (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) +\n      ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst divider = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'divider')\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding);\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\n\nlet clusterElems = {};\n\nexport const insertCluster = (elem, node) => {\n  log.trace('Inserting cluster');\n  const shape = node.shape || 'rect';\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nexport const getClusterTitleWidth = (elem, node) => {\n  const label = createLabel(node.labelText, node.labelStyle, undefined, true);\n  elem.node().appendChild(label);\n  const width = label.getBBox().width;\n  elem.node().removeChild(label);\n  return width;\n};\n\nexport const clear = () => {\n  clusterElems = {};\n};\n\nexport const positionCluster = (node) => {\n  log.info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');\n  const el = clusterElems[node.id];\n\n  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');\n};\n","import { layout as dagreLayout } from 'dagre-d3-es/src/dagre/index.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport insertMarkers from './markers';\nimport { updateNodeBounds } from './shapes/util';\nimport {\n  clear as clearGraphlib,\n  clusterDb,\n  adjustClustersAndEdges,\n  findNonClusterChild,\n  sortNodesByHierarchy,\n} from './mermaid-graphlib';\nimport { insertNode, positionNode, clear as clearNodes, setNodeElem } from './nodes';\nimport { insertCluster, clear as clearClusters } from './clusters';\nimport { insertEdgeLabel, positionEdgeLabel, insertEdge, clear as clearEdges } from './edges';\nimport { log } from '../logger';\n\nconst recursiveRender = (_elem, graph, diagramtype, parentCluster) => {\n  log.info('Graph in recursive render: XXX', graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace('Dir in recursive render - dir:', dir);\n\n  const elem = _elem.insert('g').attr('class', 'root');\n  if (!graph.nodes()) {\n    log.info('No nodes found for', graph);\n  } else {\n    log.info('Recursive render XXX', graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace('Recursive edges', graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert('g').attr('class', 'clusters');\n  const edgePaths = elem.insert('g').attr('class', 'edgePaths');\n  const edgeLabels = elem.insert('g').attr('class', 'edgeLabels');\n  const nodes = elem.insert('g').attr('class', 'nodes');\n\n  // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated\n  // to the abstract node and is later used by dagre for the layout\n  graph.nodes().forEach(function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== undefined) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      // data.clusterPositioning = true;\n      log.info('Setting data for cluster XXX (', v, ') ', data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace('Setting parent', v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      // const children = graph.children(v);\n      log.info('Cluster identified', v, node.width, graph.node(v));\n      const o = recursiveRender(nodes, node.graph, diagramtype, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info('Node bounds (abc123)', v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n\n      log.warn('Recursive render complete ', newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        // This is a cluster but not to be rendered recursively\n        // Render as before\n        log.info('Cluster - the non recursive path XXX', v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n        // insertCluster(clusters, graph.node(v));\n      } else {\n        log.info('Node - the non recursive path', v, node.id, node);\n        insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  });\n\n  // Insert labels, this will insert them into the dom so that the width can be calculated\n  // Also figure out which edges point to/from clusters and adjust them accordingly\n  // Edges from/to clusters really points to the first child in the cluster.\n  // TODO: pick optimal child in the cluster to us as link anchor\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e)));\n\n    // Check if link is either from or to a cluster\n    log.info('Fix', clusterDb, 'ids:', e.v, e.w, 'Translateing: ', clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n\n  graph.edges().forEach(function (e) {\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n  });\n  log.info('#############################################');\n  log.info('###                Layout                 ###');\n  log.info('#############################################');\n  log.info(graph);\n  dagreLayout(graph);\n  log.info('Graph after layout:', graphlibJson.write(graph));\n  // Move the nodes to the correct place\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));\n    log.info(\n      'Position ' + v + ': (' + node.x,\n      ',' + node.y,\n      ') width: ',\n      node.width,\n      ' height: ',\n      node.height\n    );\n    if (node && node.clusterNode) {\n      // clusterDb[node.id].node = node;\n\n      positionNode(node);\n    } else {\n      // Non cluster node\n      if (graph.children(v).length > 0) {\n        // A cluster in the non-recursive way\n        // positionCluster(node);\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n\n  // Move the edge labels to the correct place after layout\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);\n\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph);\n    positionEdgeLabel(edge, paths);\n  });\n\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === 'group') {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\n\nexport const render = (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clearNodes();\n  clearEdges();\n  clearClusters();\n  clearGraphlib();\n\n  log.warn('Graph at first:', graphlibJson.write(graph));\n  adjustClustersAndEdges(graph);\n  log.warn('Graph after:', graphlibJson.write(graph));\n  // log.warn('Graph ever  after:', graphlibJson.write(graph.node('A').graph));\n  recursiveRender(elem, graph, diagramtype);\n};\n\n// const shapeDefinitions = {};\n// export const addShape = ({ shapeType: fun }) => {\n//   shapeDefinitions[shapeType] = fun;\n// };\n\n// const arrowDefinitions = {};\n// export const addArrow = ({ arrowType: fun }) => {\n//   arrowDefinitions[arrowType] = fun;\n// };\n","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\n\nexport { write, read };\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound(),\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g),\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n"],"names":["$a90438664c0f255c$var$clusterDb","$a90438664c0f255c$var$descendants","$a90438664c0f255c$var$parents","$a90438664c0f255c$var$isDescendant","id","ancenstorId","$jmbVX","l","trace","includes","$a90438664c0f255c$var$copy","clusterId","graph","newGraph","rootId","warn","node","nodes","children","push","forEach","length","data","info","setNode","parent","setParent","debug","edges","edge","v","w","name","$a90438664c0f255c$var$edgeInCluster","setEdge","e","error","removeNode","$a90438664c0f255c$var$extractDescendants","res","child","$a90438664c0f255c$var$findNonClusterChild","_id","$a90438664c0f255c$var$getAnchorId","externalConnections","$a90438664c0f255c$var$extractor","depth","$c0ySZ","write","hasChildren","dir","rankdir","clusterData","clusterGraph","$4LkSm","Graph","multigraph","compound","setGraph","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","clusterNode","labelText","$a90438664c0f255c$var$sorter","result","Object","assign","sorted","$a90438664c0f255c$var$shapes","shapeSvg","insert","attr","class","rect","useHtmlLabels","k","g","flowchart","htmlLabels","label","text","labelType","$gwjTY","c","style","labelStyle","appendChild","$6raLh","bbox","getBBox","div","dv","$2YFJl","select","getBoundingClientRect","width","height","padding","halfPadding","diff","JSON","stringify","rx","ry","x","y","rectBox","intersect","point","i","classes","innerRect","append","$a90438664c0f255c$var$clusterElems","$a90438664c0f255c$var$recursiveRender","_elem","diagramtype","parentCluster","elem","clusters","edgePaths","edgeLabels","parse","o","newEl","u","s","f","dagreLayout","$a90438664c0f255c$var$sortNodesByHierarchy","p","shape","$a90438664c0f255c$var$insertCluster","paths","h","n","type","$a90438664c0f255c$export$43caf9889c228507","markers","a","clearNodes","clearEdges","removeEdge","specialId","domId","edge1","edge2","arrowTypeEnd","fromCluster","toCluster","$a90438664c0f255c$var$adjustClustersAndEdges","$3kePu","parcelRequire","$8be08bb87e59fed8$export$68d8715fc104d294","json","options","directed","isDirected","isMultigraph","isCompound","$8be08bb87e59fed8$var$writeNodes","$8be08bb87e59fed8$var$writeEdges","$1G4S6","default","value","$hNIl0","nodeValue","edgeValue","$gbpSA","$cf5967d89366f433$export$2e2bcd8739ae039"],"version":3,"file":"flowDiagram-46a15f6f.a924742f.js.map"}